# Function to attach to a session. If the session is not specified then
#just run `tmux attach`, otherwise add a -t flag
function _tmux_attach() {
    if [ $1 ]; then
        tmux attach -t $1
    else
        tmux attach
    fi
}

# Function to read man pages
function vman() {
    vim \
        -c "source \$VIMRUNTIME/ftplugin/man.vim" \
        -c "Man $*" \
        -c "set number relativenumber readonly|only"
}

# Function to set terminal title
function title() {
    local readonly text="$1"
    printf "\033]0;${text}\007"
}

# From GRB
function mcd() { mkdir -p $1 && cd $1 }

# Function to make a new tmux session at a variable location
function tnew() {
    if [[ $# -gt 0 ]]; then
        if [[ $# -gt 1 ]]; then
            return
        fi

        DIRNAME="$1"
        if [[ ! -d ${DIRNAME} ]]; then
            mkdir ${DIRNAME}
        fi

    else
        DIRNAME=$(pwd)
    fi

    cd $DIRNAME
    TMUXNAME="$(basename $(dirname $PWD))/$(basename $PWD)"
    tmux new-session -d -s ${TMUXNAME} -n ''

    test -z "${TMUX:-}" && {
        tmux attach -t ${TMUXNAME}
    } || {
        tmux switch-client -t ${TMUXNAME}
    }
}

function init-python() {
    local readonly fname="$1"
    # Remove the filename from the arugment list
    shift
    cat >${fname} <<EOL
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import division, print_function, absolute_import
import logging

logging.basicConfig(
    level=logging.INFO, format='%(asctime)s : %(message)s')
logger = logging.getLogger(__name__)


def main(args):
    if args.verbose:
        logger.setLevel(logging.DEBUG)
    logger.debug('%s', args)

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('-v', '--verbose', action='store_true')
    main(parser.parse_args())
EOL
    chmod +x ${fname}
    \vim ${fname} "${@}"
}

# Function to start jupyter notebook
function jn() {
    jupyter notebook --no-browser $@
}

# Get server SSL certificate fingerprint in MD5, SHA1 and SHA256.
# Note that OpenSSL doesn't support IPv6 at time of writing (2015-01-13).
function serversslcertfp () {
    SSSLCFFN=$(openssl s_client -showcerts -connect $1 < /dev/null)
    # To see all validity information
    echo "$SSSLCFFN"
    # For getting the fingerprints
    echo "$SSSLCFFN" | openssl x509 -md5 -fingerprint -noout
    echo "$SSSLCFFN" | openssl x509 -sha1 -fingerprint -noout
    echo "$SSSLCFFN" | openssl x509 -sha256 -fingerprint -noout
    echo "$SSSLCFFN" | openssl x509 -sha512 -fingerprint -noout
    unset SSSLCFFN
}

# Function to add timestamps to all output
function add_timestamps() {
    awk '{print strftime("[%Y/%m/%d %H:%M:%S]: ")$0}'
}

# Function to lock the screen
function lockscreen() {
    case $OSTYPE in
        darwin*)
            /System/Library/CoreServices/Menu\ Extras/User.menu/Contents/Resources/CGSession -suspend
            ;;
    esac
}

function build-movie() {
    local dirname="$1"
    local output="$2"

    local fulloutpath="$(readlink -f ${output})"

    echo "Rendering movie out of pngs in ${dirname} to ${fulloutpath}"

    (cd ${dirname} && mencoder 'mf://*.png' -mf w=800:h=600:fps=30:type=png -ovc x264 -x264encopts crf=18:nofast_pskip:nodct_decimate:nocabac:global_header:threads=12 -of lavf -lavfopts format=mp4 -o "${fulloutpath}")
}

# Expose the current directory using a python webserver
# - handles importing http.server or SimpleHTTPServer
function webshare() {
    if has_executable python3; then
        python3 -m http.server $*
    else
        python2 -m SimpleHTTPServer $*
    fi
}

# Speed up git completion
__git_files () {
    _wanted files expl 'local files' _files
}

# Functions to load mutt. They change the current directory to the download
# directory so that any attachments are automatically saved there
function mutt() {
    (cd ~/Downloads
    if has_executable neomutt; then
        =neomutt;
    else
        =mutt
    fi)
}
alias email=mutt

function lb() {
    LOGBOOK_DIR=${HOME}/logbook
    if [ ! -d ${LOGBOOK_DIR} ]; then
        mkdir -p ${LOGBOOK_DIR}
    fi

    vim ${LOGBOOK_DIR}/$(date '+%Y-%m-%d').md
}

# Function to create a quick git commit
function commit() {
    if [[ $# == 0 ]]; then
        git commit
    else
        git commit -m "$*"
    fi
}

alias c=commit
alias com=commit

# Function to add to my did.txt file
function did() {
    =vim +'normal Go' +'r!date' ~/did.txt
}

function task() {
    if [ -f ${PWD}/.taskrc ]; then
        =task rc:${PWD}/.taskrc $*
    else
        =task $*
    fi
}

_not_inside_tmux() { [[ -z "$TMUX" ]] }

# Prevent nested tmux problem
function ssh() {
    if _not_inside_tmux; then
        =ssh $*
    else
        # Check hostname is not in blacklist
        for name in "astoria"; do
            if $(echo "$*" | grep -q "astoria"); then
                echo "Cannot ssh to this host inside the current tmux session. The host is also configured to use tmux and so would cause a nested tmux issue." >&2
                return
            fi
        done

        =ssh $*
    fi
}

# Function to source the current virtual environment if there is one
function se() {
    if has_executable direnv; then
        grep -q 'layout python-venv' .envrc 2>/dev/null || {
            echo layout python-venv >> .envrc
            direnv allow .
        }
    else
        if [[ -f ./venv/bin/activate ]]; then
            # Have to check that the shell is not currently in a virtual environment
            test -z $VIRTUAL_ENV || {
                echo "Current shell is in a virtual environment ($VIRTUAL_ENV). Deactivating" >&2
                deactivate
            }
            source ./venv/bin/activate
        else
            # Create the virtual environment
            echo "Virtual environment does not exist, creating" >&2
            if has_executable python3; then
                python3 -m venv ./venv
            else
                # Hope python is python3!
                python -m venv ./venv
            fi
            echo "Installing latest version of pip"
            ./venv/bin/pip install -U pip
            se
        fi
    fi
}

# Function to get the hierarchical process tree upwards (usually ending at PID 1)
function pparents() {
    if [[ $# -ne 1 ]]; then
        echo "Usage: pparents <pid>" >&2
        return 1
    fi

    pstree -s -p $1
}

# Function to grep for specific process lines
function psgrep() {
    if [[ $# -ne 1 ]]; then
        echo "Usage: psgrep <name>" >&2
        return 1
    fi

    ps aux | grep $1
}

function find_pi() {
    if [[ $# != 1 ]]; then
        echo "usage: find_pi <interface>" >&2
        return 1
    fi

    local interface=$1

    echo "Usage may require sudo password"
    sudo arp-scan --interface=$interface --localnet | grep b8:27:eb | awk '{print $1}'
}

function wakeastoria() {
    wakeonlan -i 192.168.0.255 -p 7 40:B0:76:DE:79:B3 >/dev/null
    readonly ip_address="$(nslookup astoria | grep Address | grep 192 | awk '{print $2}')"
    test -z ${ip_address} && {
        ping -o 192.168.0.10 >/dev/null
    } || {
        ping -o ${ip_address} >/dev/null
    }
}

function pushdotfiles() {
    (cd ${HOME}/dotfiles && __pushdotfiles)
}

function __pushdotfiles() {
    git diff --quiet HEAD || {
        echo "dotfiles dir not clean"
        return
    }

    git push
}

# Open the video in a native viewer (mpv if exists)
function video() {
    if [[ $# != 1 ]]; then
        echo "usage: video <url>" >&2
        return 1
    fi

    local url=$1
    case $OSTYPE in
        darwin*)
            open $1 -a mpv
            ;;
    esac
}

function cwd-of() {
    local pid=$1
    test -z "${pid:-}" && {
        echo "Usage: cwd-of <pid>" >&2
        exit 1
    }

    case $OSTYPE in
        darwin*)
            lsof -p $pid | grep cwd | rev | awk '{print $1}' | rev
            ;;
        *)
            echo "Not implemented" >&2
            exit 1
            ;;
    esac
}

function s() {
    clear
    figlet "pwd"
    pwd
    figlet "ls"
    ls
    figlet "git status"
    git status
}

function find_up() {
  (
    while true; do
      if [[ -f $1 ]]; then
        echo "$PWD/$1"
        return 0
      fi
      if [[ $PWD == / ]] || [[ $PWD == // ]]; then
        return 1
      fi
      cd ..
    done
  )
}

function poetry-env-rm() {
    poetry env remove $(poetry env info --path)/bin/python
}

function gitignore() {
    if [ $# -ne 1 ]; then
        echo "Usage: gitignore <keys>" >&2
        echo >&2
        echo "  where keys is a comma separated list of tags" >&2
        return 1
    fi

    curl -LsSo .gitignore https://gitignore.io/api/$1
}

# function to open vim with the livegrep feature
function gl() {
    if [ $# -eq 0 ]; then
        vim -c "lua require('telescope.builtin').live_grep()"
    else
        cwd=$1
        cmd="lua require('telescope.builtin').live_grep({ search_dirs = {'$cwd'} })"
        vim -c "$cmd"
    fi
}
